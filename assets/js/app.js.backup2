/**
 * RFCE - Senior Living Community JavaScript
 * Enhanced with semantic image matching and animations
 */

const RFCEApp = {
  // Semantic Image Service with project-specific images
  IMAGE_MAP: {
    'community-life': [
      'https://communityandcare.com.au/wp-content/uploads/2020/11/community-and-care-group-center-activity.jpg',
      'https://www.blog.oxitone.com/wp-content/uploads/2021/08/improving-quality-of-care-in-nursing-homes.jpg',
      'https://assistedlivingeducation.com/wp-content/uploads/2025/04/wellness-Leonardo_Kino_XL_A_vividly_thriving_group_of_elderly_residents_0.jpg'
    ],
    'dining': [
      'https://assistedlivingeducation.com/wp-content/uploads/2018/03/AdobeStock_175564448-1030x687.jpeg',
      'https://tse2.mm.bing.net/th/id/OIP.8FikOlX9boXVBOktdZoPhQHaHa?r=0&pid=ImgDet&w=198&h=198&c=7&o=7&rm=3'
    ],
    'wellness': [
      'https://assistedlivingeducation.com/wp-content/uploads/2025/04/wellness-Leonardo_Kino_XL_A_vividly_thriving_group_of_elderly_residents_0.jpg',
      'https://tse3.mm.bing.net/th/id/OIP.LlMGZhlTdbqusNaiKtPljgHaEo?r=0&rs=1&pid=ImgDetMain&o=7&rm=3'
    ],
    'residences': [
      'https://tse3.mm.bing.net/th/id/OIP.LlMGZhlTdbqusNaiKtPljgHaEo?r=0&rs=1&pid=ImgDetMain&o=7&rm=3',
      'https://assistedlivingeducation.com/wp-content/uploads/2018/03/AdobeStock_175564448-1030x687.jpeg'
    ],
    'nature': [
      'https://tse3.mm.bing.net/th/id/OIP.LlMGZhlTdbqusNaiKtPljgHaEo?r=0&rs=1&pid=ImgDetMain&o=7&rm=3',
      'https://communityandcare.com.au/wp-content/uploads/2020/11/community-and-care-group-center-activity.jpg'
    ],
    'team': [
      'https://www.blog.oxitone.com/wp-content/uploads/2021/08/improving-quality-of-care-in-nursing-homes.jpg',
      'https://assistedlivingeducation.com/wp-content/uploads/2025/04/wellness-Leonardo_Kino_XL_A_vividly_thriving_group_of_elderly_residents_0.jpg'
    ]
  },
  // Enhanced gallery data with project-specific images
  galleryImages: [
    { id: 1, src: 'https://assistedlivingeducation.com/wp-content/uploads/2018/03/AdobeStock_175564448-1030x687.jpeg', alt: 'Elegant community dining room with seniors enjoying meals together', tags: ['dining', 'people'], topic: 'dining' },
    { id: 2, src: 'https://tse3.mm.bing.net/th/id/OIP.LlMGZhlTdbqusNaiKtPljgHaEo?r=0&rs=1&pid=ImgDetMain&o=7&rm=3', alt: 'Beautiful garden courtyard with walking paths and peaceful seating', tags: ['places', 'wellness'], topic: 'nature' },
    { id: 3, src: 'https://tse2.mm.bing.net/th/id/OIP.8FikOlX9boXVBOktdZoPhQHaHa?r=0&pid=ImgDet&w=198&h=198&c=7&o=7&rm=3', alt: 'Modern senior living apartment with comfortable furnishings', tags: ['places'], topic: 'residences' },
    { id: 5, src: 'https://communityandcare.com.au/wp-content/uploads/2020/11/community-and-care-group-center-activity.jpg', alt: 'Comfortable common area with fireplace and social spaces', tags: ['places'], topic: 'community-life' },
    { id: 6, src: 'https://www.blog.oxitone.com/wp-content/uploads/2021/08/improving-quality-of-care-in-nursing-homes.jpg', alt: 'Professional staff providing quality care and support', tags: ['people'], topic: 'team' },
    { id: 7, src: 'https://assistedlivingeducation.com/wp-content/uploads/2025/04/wellness-Leonardo_Kino_XL_A_vividly_thriving_group_of_elderly_residents_0.jpg', alt: 'Residents enjoying social activities and community events', tags: ['people'], topic: 'community-life' },
    { id: 8, src: 'https://tse3.mm.bing.net/th/id/OIP.LlMGZhlTdbqusNaiKtPljgHaEo?r=0&rs=1&pid=ImgDetMain&o=7&rm=3', alt: 'Peaceful library with comfortable reading chairs and natural light', tags: ['places'], topic: 'residences' },
    { id: 9, src: 'https://assistedlivingeducation.com/wp-content/uploads/2025/04/wellness-Leonardo_Kino_XL_A_vividly_thriving_group_of_elderly_residents_0.jpg', alt: 'Wellness center with modern exercise equipment and programs', tags: ['wellness'], topic: 'wellness' },
    { id: 10, src: 'https://communityandcare.com.au/wp-content/uploads/2020/11/community-and-care-group-center-activity.jpg', alt: 'Outdoor terrace with beautiful views and fresh air', tags: ['places'], topic: 'nature' },
    { id: 11, src: 'https://www.blog.oxitone.com/wp-content/uploads/2021/08/improving-quality-of-care-in-nursing-homes.jpg', alt: 'Community event space for gatherings and celebrations', tags: ['people', 'places'], topic: 'community-life' },
    { id: 12, src: 'https://assistedlivingeducation.com/wp-content/uploads/2025/04/wellness-Leonardo_Kino_XL_A_vividly_thriving_group_of_elderly_residents_0.jpg', alt: 'Spa and wellness facilities for relaxation and health', tags: ['wellness'], topic: 'wellness' }
  ],


  currentImageIndex: 0,
  currentImages: [],

  // About Carousel State
  aboutCarousel: {
    currentIndex: 0,
    images: [],
    autoSlideTimer: null,
    isUserInteracting: false
  },

  // Initialize
  init() {
    this.initTheme();
    this.initNavigation();
    this.initReveal();
    this.initParallaxHero();
    this.initImageErrors();
    this.applySemanticImages();
    this.initTourScheduler();
    this.initAboutCarousel();
    
    const path = window.location.pathname;
    console.log('🌟 Initializing page:', path);
    
    if (path.includes('gallery')) { 
      console.log('🌟 Gallery page: Will call initGallery() (Supabase)'); 
      this.initLightbox(); 
    }
    else if (path.includes('contact')) { this.initContact(); }
    else { this.initHome(); }
    
    // Auto-open tour modal if URL has #tour
    if (window.location.hash === '#tour') {
      this.openTourModal();
    }
  },

  // Semantic Image Service
  pickImage(topic, keywords = []) {
    const images = this.IMAGE_MAP[topic] || this.IMAGE_MAP['community-life'];
    const selectedUrl = images[Math.floor(Math.random() * images.length)];
    
    const altText = keywords.length > 0 
      ? `${keywords.slice(0, 3).join(', ')} at RFCE senior living community`
      : `Beautiful ${topic.replace('-', ' ')} at RFCE senior living community`;
    
    const caption = keywords.length > 0
      ? keywords.slice(0, 2).join(' and ')
      : topic.replace('-', ' ');
    
    return { url: selectedUrl, alt: altText, caption };
  },

  extractKeywords(text) {
    const words = text.toLowerCase()
      .replace(/[^a-z\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 3)
      .filter(word => !['this', 'that', 'with', 'from', 'they', 'have', 'will', 'been', 'were', 'their', 'there', 'would', 'could', 'should'].includes(word));
    
    return [...new Set(words)].slice(0, 7);
  },

  applySemanticImages() {
    document.querySelectorAll('[data-topic]').forEach(section => {
      const topic = section.dataset.topic;
      const copyElement = section.querySelector('.copy');
      const imgElement = section.querySelector('.paired-img');
      const captionElement = section.querySelector('.caption');
      
      if (copyElement && imgElement) {
        const keywords = this.extractKeywords(copyElement.textContent);
        const { url, alt, caption } = this.pickImage(topic, keywords);
        
        imgElement.src = url;
        imgElement.alt = alt;
        if (captionElement) {
          captionElement.textContent = caption;
        }
      }
    });
  },

  // Enhanced scroll reveal with stagger
  initReveal() {
    const observer = new IntersectionObserver(entries => {
      entries.forEach((entry, index) => {
        if (entry.isIntersecting) {
          setTimeout(() => {
            entry.target.classList.add('visible');
          }, index * 100);
        }
      });
    }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });

    document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
  },

  // Parallax hero (disabled for reduced motion)
  initParallaxHero() {
    const hero = document.querySelector('.hero');
    if (!hero || window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
    
    let ticking = false;
    
    const updateParallax = () => {
      const scrolled = window.pageYOffset;
      const rate = scrolled * -0.03;
      const maxOffset = 12;
      const offset = Math.max(-maxOffset, Math.min(maxOffset, rate));
      
      hero.style.transform = `translateY(${offset}px)`;
      ticking = false;
    };
    
    const requestTick = () => {
      if (!ticking) {
        requestAnimationFrame(updateParallax);
        ticking = true;
      }
    };
    
    window.addEventListener('scroll', requestTick, { passive: true });
  },

  // Theme
  initTheme() {
    const saved = localStorage.getItem('rfce-theme') || 'light';
    document.documentElement.setAttribute('data-theme', saved);
    
    const toggle = document.querySelector('.theme-toggle');
    if (toggle) {
      toggle.addEventListener('click', () => {
        const current = document.documentElement.getAttribute('data-theme');
        const next = current === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('rfce-theme', next);
      });
    }
  },

  // Navigation
  initNavigation() {
    const path = window.location.pathname;
    document.querySelectorAll('.nav-link').forEach(link => {
      const href = link.getAttribute('href');
      if (path.includes(href) || (path === '/' && href === 'index.html')) {
        link.classList.add('active');
      }
    });
  },

  // Legacy scroll reveal (replaced by initReveal)
  // This method is kept for any remaining references
  initScrollReveal() {
    this.initReveal();
  },

  // Image error handling
  initImageErrors() {
    document.addEventListener('error', e => {
      if (e.target.tagName === 'IMG') {
        // Use one of our project images as fallback
        e.target.src = 'https://communityandcare.com.au/wp-content/uploads/2020/11/community-and-care-group-center-activity.jpg';
      }
    }, true);
  },

  // Home page
  initHome() {
    this.renderLifestyle();
    this.renderBlogPreview();
  },

  renderLifestyle() {
    const container = document.querySelector('.lifestyle-grid');
    if (!container) return;

    container.innerHTML = this.galleryImages.slice(0, 5).map(img => `
      <div class="lifestyle-item reveal-stagger">
        <img src="${img.src}" alt="${img.alt}" loading="lazy" onerror="this.src='./assets/img/fallback.jpg'">
        <div class="lifestyle-overlay">${img.alt.split(' ').slice(0, 3).join(' ')}</div>
      </div>
    `).join('');

    container.addEventListener('click', () => window.location.href = './gallery.html');
  },

  renderBlogPreview() {
    const container = document.querySelector('.blog-grid');
    if (!container) return;

    container.innerHTML = this.blogPosts.slice(0, 3).map(post => `
      <article class="blog-card reveal-stagger">
        <div class="blog-image">
          <img src="${post.image}" alt="${post.title}" loading="lazy" onerror="this.src='./assets/img/fallback.jpg'">
        </div>
        <div class="blog-content">
          <div class="blog-meta">
            <time>${this.formatDate(post.date)}</time>
            ${post.tags.map(tag => `<span class="blog-tag">${tag}</span>`).join('')}
          </div>
          <h3 class="blog-title">${post.title}</h3>
          <p>${post.excerpt}</p>
        </div>
      </article>
    `).join('');

    container.addEventListener('click', () => window.location.href = './blog.html');
  },

  // Gallery
  initGallery() {
    const container = document.querySelector('.gallery-grid');
    if (!container) return;

    container.innerHTML = this.galleryImages.map(img => `
      <div class="gallery-item reveal-stagger" data-tags="${img.tags.join(' ')}" data-id="${img.id}">
        <img src="${img.src}" alt="${img.alt}" loading="lazy" onerror="this.src='./assets/img/fallback.jpg'">
      </div>
    `).join('');

    container.addEventListener('click', e => {
      const item = e.target.closest('.gallery-item');
      if (item) this.openLightbox(parseInt(item.dataset.id));
    });

    // Filters
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const filter = btn.dataset.filter;
        document.querySelectorAll('.gallery-item').forEach(item => {
          if (filter === 'all' || item.dataset.tags.includes(filter)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      });
    });
  },

  // Lightbox
  initLightbox() {
    if (document.querySelector('.lightbox')) return;

    document.body.insertAdjacentHTML('beforeend', `
      <div class="lightbox">
        <div class="lightbox-content">
          <button class="lightbox-close">&times;</button>
          <button class="lightbox-nav lightbox-prev">&#8249;</button>
          <img class="lightbox-image" src="" alt="">
          <button class="lightbox-nav lightbox-next">&#8250;</button>
          <div class="lightbox-caption"></div>
        </div>
      </div>
    `);

    const lightbox = document.querySelector('.lightbox');
    
    // Events
    document.querySelector('.lightbox-close').addEventListener('click', () => this.closeLightbox());
    document.querySelector('.lightbox-prev').addEventListener('click', () => this.showPrevImage());
    document.querySelector('.lightbox-next').addEventListener('click', () => this.showNextImage());
    
    lightbox.addEventListener('click', e => {
      if (e.target === lightbox) this.closeLightbox();
    });

    document.addEventListener('keydown', e => {
      if (!lightbox.classList.contains('active')) return;
      if (e.key === 'Escape') this.closeLightbox();
      if (e.key === 'ArrowLeft') this.showPrevImage();
      if (e.key === 'ArrowRight') this.showNextImage();
    });

    // Modal images
    document.addEventListener('click', e => {
      if (e.target.classList.contains('modal-image')) {
        this.currentImages = [{ src: e.target.src, alt: e.target.alt }];
        this.currentImageIndex = 0;
        this.showLightboxImage();
        lightbox.classList.add('active');
      }
    });
  },

  openLightbox(imageId) {
    const image = this.galleryImages.find(img => img.id === imageId);
    if (!image) return;

    this.currentImages = this.galleryImages;
    this.currentImageIndex = this.galleryImages.findIndex(img => img.id === imageId);
    this.showLightboxImage();
    document.querySelector('.lightbox').classList.add('active');
  },

  showLightboxImage() {
    const img = document.querySelector('.lightbox-image');
    const caption = document.querySelector('.lightbox-caption');
    const current = this.currentImages[this.currentImageIndex];
    
    img.src = current.src;
    img.alt = current.alt;
    caption.textContent = current.alt;
  },

  showPrevImage() {
    this.currentImageIndex = (this.currentImageIndex - 1 + this.currentImages.length) % this.currentImages.length;
    this.showLightboxImage();
  },

  showNextImage() {
    this.currentImageIndex = (this.currentImageIndex + 1) % this.currentImages.length;
    this.showLightboxImage();
  },

  closeLightbox() {
    document.querySelector('.lightbox').classList.remove('active');
  },

  // About Carousel Methods
  initAboutCarousel() {
    const carousel = document.querySelector('.about-carousel');
    if (!carousel) return;

    // Get all unique images from our gallery
    this.aboutCarousel.images = this.getAllProjectImages();
    this.aboutCarousel.currentIndex = 0;

    this.renderAboutCarousel();
    this.bindAboutCarouselEvents();
    this.startAboutCarouselAutoSlide();
  },

  getAllProjectImages() {
    // Collect unique images from all our project categories
    const allImages = new Set();
    
    // Add images from galleryImages array (these are our main uploaded images)
    this.galleryImages.forEach(img => {
      allImages.add(JSON.stringify({ src: img.src, alt: img.alt, id: img.id || 0 }));
    });
    
    // Add images from IMAGE_MAP
    Object.values(this.IMAGE_MAP).forEach(imageArray => {
      imageArray.forEach(src => {
        allImages.add(JSON.stringify({ 
          src, 
          alt: 'Beautiful moment at RFCE Senior Living Community',
          id: 0 // Default ID for IMAGE_MAP images
        }));
      });
    });
    
    // Convert back to array and sort by ID (descending) to get newest first
    const imageArray = Array.from(allImages).map(imgStr => JSON.parse(imgStr));
    const sortedImages = imageArray.sort((a, b) => (b.id || 0) - (a.id || 0));
    
    // Return only the last 12 uploaded pictures (most recent)
    return sortedImages.slice(0, 12);
  },

  renderAboutCarousel() {
    const slidesContainer = document.querySelector('.carousel-slides');
    const indicatorsContainer = document.querySelector('.carousel-indicators');
    
    if (!slidesContainer || !indicatorsContainer) return;

    // Render slides
    slidesContainer.innerHTML = this.aboutCarousel.images.map((img, index) => `
      <div class="carousel-slide ${index === 0 ? 'active' : ''}">
        <img src="${img.src}" alt="${img.alt}" loading="lazy" onerror="this.src='https://communityandcare.com.au/wp-content/uploads/2020/11/community-and-care-group-center-activity.jpg'">
      </div>
    `).join('');

    // Render indicators
    indicatorsContainer.innerHTML = this.aboutCarousel.images.map((_, index) => `
      <button class="carousel-indicator ${index === 0 ? 'active' : ''}" data-index="${index}" aria-label="Go to slide ${index + 1}"></button>
    `).join('');
  },

  bindAboutCarouselEvents() {
    const prevBtn = document.querySelector('.carousel-prev');
    const nextBtn = document.querySelector('.carousel-next');
    const indicators = document.querySelectorAll('.carousel-indicator');
    const carousel = document.querySelector('.about-carousel');

    // Navigation buttons
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        this.aboutCarouselPrev();
        this.handleAboutCarouselUserInteraction();
      });
    }

    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        this.aboutCarouselNext();
        this.handleAboutCarouselUserInteraction();
      });
    }

    // Indicator buttons
    indicators.forEach((indicator, index) => {
      indicator.addEventListener('click', () => {
        this.aboutCarouselGoTo(index);
        this.handleAboutCarouselUserInteraction();
      });
    });

    // Pause auto-slide on hover
    if (carousel) {
      carousel.addEventListener('mouseenter', () => {
        this.stopAboutCarouselAutoSlide();
      });

      carousel.addEventListener('mouseleave', () => {
        if (!this.aboutCarousel.isUserInteracting) {
          this.startAboutCarouselAutoSlide();
        }
      });
    }
  },

  aboutCarouselPrev() {
    const newIndex = (this.aboutCarousel.currentIndex - 1 + this.aboutCarousel.images.length) % this.aboutCarousel.images.length;
    this.aboutCarouselGoTo(newIndex);
  },

  aboutCarouselNext() {
    const newIndex = (this.aboutCarousel.currentIndex + 1) % this.aboutCarousel.images.length;
    this.aboutCarouselGoTo(newIndex);
  },

  aboutCarouselGoTo(index) {
    if (index === this.aboutCarousel.currentIndex) return;

    const slides = document.querySelectorAll('.carousel-slide');
    const indicators = document.querySelectorAll('.carousel-indicator');

    // Remove active classes
    slides[this.aboutCarousel.currentIndex]?.classList.remove('active');
    indicators[this.aboutCarousel.currentIndex]?.classList.remove('active');

    // Update index
    this.aboutCarousel.currentIndex = index;

    // Add active classes
    slides[this.aboutCarousel.currentIndex]?.classList.add('active');
    indicators[this.aboutCarousel.currentIndex]?.classList.add('active');
  },

  startAboutCarouselAutoSlide() {
    this.stopAboutCarouselAutoSlide();
    this.aboutCarousel.autoSlideTimer = setInterval(() => {
      this.aboutCarouselNext();
    }, 4000); // 4 seconds as requested
  },

  stopAboutCarouselAutoSlide() {
    if (this.aboutCarousel.autoSlideTimer) {
      clearInterval(this.aboutCarousel.autoSlideTimer);
      this.aboutCarousel.autoSlideTimer = null;
    }
  },

  handleAboutCarouselUserInteraction() {
    this.aboutCarousel.isUserInteracting = true;
    this.stopAboutCarouselAutoSlide();
    
    // Resume auto-slide after 8 seconds of no interaction
    setTimeout(() => {
      this.aboutCarousel.isUserInteracting = false;
      this.startAboutCarouselAutoSlide();
    }, 8000);
  },


  // Modal
  initModal() {
    if (document.querySelector('.modal')) return;

    document.body.insertAdjacentHTML('beforeend', `
      <div class="modal">
        <div class="modal-content">
          <div class="modal-header">
            <button class="modal-close">&times;</button>
            <h1 class="modal-title"></h1>
            <div class="modal-meta"></div>
          </div>
          <div class="modal-body">
            <img class="modal-image" src="" alt="">
            <div class="modal-text"></div>
          </div>
        </div>
      </div>
    `);

    const modal = document.querySelector('.modal');
    document.querySelector('.modal-close').addEventListener('click', () => modal.classList.remove('active'));
    modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('active'); });
    document.addEventListener('keydown', e => { if (e.key === 'Escape') modal.classList.remove('active'); });
  },


  // Contact
  initContact() {
    const form = document.querySelector('.contact-form');
    if (!form) return;

    form.addEventListener('submit', e => {
      e.preventDefault();
      
      const inputs = form.querySelectorAll('.form-input, .form-textarea');
      let valid = true;

      inputs.forEach(input => {
        const group = input.closest('.form-group');
        const error = group.querySelector('.form-error');
        
        if (!input.value.trim()) {
          group.classList.add('error');
          error.textContent = `${input.name} is required`;
          error.style.display = 'block';
          valid = false;
        } else if (input.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input.value)) {
          group.classList.add('error');
          error.textContent = 'Please enter a valid email';
          error.style.display = 'block';
          valid = false;
        } else {
          group.classList.remove('error');
          error.style.display = 'none';
        }
      });

      if (valid) {
        this.showToast('Message sent successfully! We\'ll get back to you soon.');
        form.reset();
      }
    });

    // Clear errors on input
    form.querySelectorAll('.form-input, .form-textarea').forEach(input => {
      input.addEventListener('input', () => {
        input.closest('.form-group').classList.remove('error');
      });
    });
  },

  // Utilities
  formatDate(dateStr) {
    return new Date(dateStr).toLocaleDateString('en-US', {
      year: 'numeric', month: 'long', day: 'numeric'
    });
  },

  showToast(message, isError = false) {
    const toast = document.createElement('div');
    toast.className = `toast ${isError ? 'error' : ''}`;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => toast.classList.add('show'), 100);
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 250);
    }, 3000);
  },

  // Tour Scheduler
  tourState: {
    step: 1,
    date: null,
    time: null,
    details: {
      name: '',
      email: '',
      phone: '',
      notes: '',
      for: 'self'
    }
  },

  initTourScheduler() {
    // Create modal HTML
    this.createTourModal();
    
    // Bind tour trigger buttons
    document.querySelectorAll('[data-action="schedule-tour"]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        this.openTourModal();
      });
    });
    
    // Restore draft from localStorage
    this.restoreTourDraft();
  },

  createTourModal() {
    if (document.querySelector('.tour-backdrop')) return;

    const modalHTML = `
      <div class="tour-backdrop" id="tourModal">
        <div class="tour-modal">
          <div class="tour-header">
            <button class="tour-close" aria-label="Close tour scheduler">&times;</button>
            <h2 class="tour-title">Schedule a Tour</h2>
            <p class="tour-subtitle">Find the perfect time to visit our community</p>
          </div>
          
          <div class="tour-steps">
            <div class="tour-step active" data-step="1">
              <div class="tour-step-number">1</div>
              <div class="tour-step-label">Date</div>
            </div>
            <div class="tour-step-connector"></div>
            <div class="tour-step" data-step="2">
              <div class="tour-step-number">2</div>
              <div class="tour-step-label">Time</div>
            </div>
            <div class="tour-step-connector"></div>
            <div class="tour-step" data-step="3">
              <div class="tour-step-number">3</div>
              <div class="tour-step-label">Details</div>
            </div>
            <div class="tour-step-connector"></div>
            <div class="tour-step" data-step="4">
              <div class="tour-step-number">4</div>
              <div class="tour-step-label">Confirm</div>
            </div>
          </div>
          
          <div class="tour-content">
            <div class="tour-step-content active"></div>
          </div>
          
          <div class="tour-nav">
            <div class="tour-nav-left">
              <button class="btn btn--ghost tour-back" style="display: none;">← Back</button>
            </div>
            <div class="tour-nav-right">
              <button class="btn btn-primary tour-next" disabled>Next →</button>
            </div>
          </div>
          
          <div class="tour-announcements" aria-live="polite" aria-atomic="true"></div>
        </div>
      </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHTML);
    this.bindTourEvents();
  },

  bindTourEvents() {
    const modal = document.querySelector('.tour-backdrop');
    const closeBtn = document.querySelector('.tour-close');
    const backBtn = document.querySelector('.tour-back');
    const nextBtn = document.querySelector('.tour-next');

    // Close events
    closeBtn.addEventListener('click', () => this.closeTourModal());
    modal.addEventListener('click', (e) => {
      if (e.target === modal) this.closeTourModal();
    });

    // Navigation
    backBtn.addEventListener('click', () => this.tourPrevStep());
    nextBtn.addEventListener('click', () => this.tourNextStep());

    // Keyboard events
    document.addEventListener('keydown', (e) => {
      if (!modal.classList.contains('active')) return;
      
      if (e.key === 'Escape') {
        this.closeTourModal();
      }
    });
  },

  openTourModal() {
    const modal = document.querySelector('.tour-backdrop');
    modal.classList.add('active');
    this.renderTourStep();
    this.trapFocus(modal);
    
    // Store the trigger element for focus restoration
    this.tourTrigger = document.activeElement;
  },

  closeTourModal() {
    const modal = document.querySelector('.tour-backdrop');
    modal.classList.remove('active');
    this.releaseFocus();
    
    // Restore focus to trigger
    if (this.tourTrigger) {
      this.tourTrigger.focus();
    }
  },

  tourNextStep() {
    if (this.tourState.step < 4) {
      this.tourState.step++;
      this.saveTourDraft();
      this.renderTourStep();
    }
  },

  tourPrevStep() {
    if (this.tourState.step > 1) {
      this.tourState.step--;
      this.renderTourStep();
    }
  },

  renderTourStep() {
    const content = document.querySelector('.tour-step-content');
    const backBtn = document.querySelector('.tour-back');
    const nextBtn = document.querySelector('.tour-next');
    
    // Update stepper
    document.querySelectorAll('.tour-step').forEach((step, index) => {
      const stepNum = index + 1;
      step.classList.toggle('active', stepNum === this.tourState.step);
      step.classList.toggle('completed', stepNum < this.tourState.step);
    });
    
    // Show/hide navigation
    backBtn.style.display = this.tourState.step > 1 ? 'block' : 'none';
    
    // Render step content
    switch (this.tourState.step) {
      case 1:
        this.renderCalendarStep(content);
        nextBtn.textContent = 'Next →';
        nextBtn.disabled = !this.tourState.date;
        break;
      case 2:
        nextBtn.textContent = 'Next →';
        nextBtn.disabled = !this.tourState.time;
        this.renderTimeStep(content); // Now async but we don't await here to avoid blocking UI
        break;
      case 3:
        this.renderDetailsStep(content);
        nextBtn.textContent = 'Next →';
        nextBtn.disabled = !this.validateDetails();
        break;
      case 4:
        this.renderConfirmStep(content);
        nextBtn.style.display = 'none';
        break;
    }
    
    // Add reveal animation
    content.classList.remove('visible');
    setTimeout(() => content.classList.add('visible'), 50);
  },

  renderCalendarStep(container) {
    const today = new Date();
    const currentDate = this.tourCalendarDate || new Date();
    
    container.innerHTML = `
      <div class="cal">
        <div class="cal__header">
          <button class="cal__nav" data-action="prev-month" aria-label="Previous month">‹</button>
          <div class="cal__month">${this.formatMonthYear(currentDate)}</div>
          <button class="cal__nav" data-action="next-month" aria-label="Next month">›</button>
        </div>
        <div class="cal__grid">
          ${this.renderCalendarGrid(currentDate)}
        </div>
      </div>
    `;
    
    // Bind calendar events
    container.querySelector('[data-action="prev-month"]').addEventListener('click', () => {
      this.tourCalendarDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
      this.renderCalendarStep(container);
    });
    
    container.querySelector('[data-action="next-month"]').addEventListener('click', () => {
      this.tourCalendarDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
      this.renderCalendarStep(container);
    });
    
    // Bind day selection
    container.querySelectorAll('.cal__day:not(.cal__day--disabled)').forEach(dayBtn => {
      dayBtn.addEventListener('click', () => {
        const date = dayBtn.dataset.date;
        this.tourState.date = date;
        // Clear time selection when date changes
        this.tourState.time = null;
        this.tourState.selectedHour = null;
        this.tourState.selectedMinute = null;
        this.saveTourDraft();
        
        // Update UI
        container.querySelectorAll('.cal__day').forEach(d => d.classList.remove('cal__day--selected'));
        dayBtn.classList.add('cal__day--selected');
        
        // Enable next button
        document.querySelector('.tour-next').disabled = false;
      });
    });
  },

  renderCalendarGrid(date) {
    const year = date.getFullYear();
    const month = date.getMonth();
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Reset time for accurate comparison
    const maxDate = new Date();
    maxDate.setDate(maxDate.getDate() + 90);
    
    // Get first day of month and days in month
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startingDay = firstDay.getDay();
    
    let html = '';
    
    // Day headers
    ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'].forEach(day => {
      html += `<div class="cal__day-header">${day}</div>`;
    });
    
    // Empty cells for days before month starts
    for (let i = 0; i < startingDay; i++) {
      html += '<div class="cal__day cal__day--other-month"></div>';
    }
    
    // Days of the month
    for (let day = 1; day <= daysInMonth; day++) {
      const currentDate = new Date(year, month, day);
      const dateStr = this.formatDateISO(currentDate);
      const isPast = currentDate < today;
      const isFuture = currentDate > maxDate;
      const isToday = this.isSameDay(currentDate, new Date());
      const isSelected = this.tourState.date === dateStr;
      
      const classes = ['cal__day'];
      if (isPast || isFuture) classes.push('cal__day--disabled');
      if (isToday) classes.push('cal__day--today');
      if (isSelected) classes.push('cal__day--selected');
      
      html += `<button class="${classes.join(' ')}" data-date="${dateStr}" ${isPast || isFuture ? 'disabled' : ''}>${day}</button>`;
    }
    
    return html;
  },

  async renderTimeStep(container) {
    const selectedDate = new Date(this.tourState.date);
    const isToday = this.isSameDay(selectedDate, new Date());
    const currentHour = new Date().getHours();
    
    // Show loading state
    container.innerHTML = `
      <div class="tour-form">
        <h3>Choose your preferred time</h3>
        <p>Loading availability for ${this.formatDateLong(selectedDate)}...</p>
        <div class="times"></div>
      </div>
    `;
    
    try {
      // Get booked slots from Supabase
      const bookedTimes = await TourScheduler.getBookedSlotsForDay(selectedDate);
      
      // Add past times if today
      const disabledTimes = [...bookedTimes];
      if (isToday) {
        for (let hour = 9; hour <= currentHour; hour++) {
          const timeStr = `${hour.toString().padStart(2, '0')}:00`;
          if (!disabledTimes.includes(timeStr)) {
            disabledTimes.push(timeStr);
          }
        }
      }
      
      // Update content with actual availability
      container.innerHTML = `
        <div class="tour-form">
          <h3>Choose your preferred time</h3>
          <p>Available times for ${this.formatDateLong(selectedDate)}</p>
          <div class="times"></div>
        </div>
      `;
      
      // Paint availability
      TourScheduler.paintAvailability(container, disabledTimes, this.tourState.time);
      
      // Bind time selection events
      container.querySelectorAll('.time__slot:not(.time__slot--disabled)').forEach(timeBtn => {
        timeBtn.addEventListener('click', () => {
          const time = timeBtn.dataset.time;
          this.tourState.time = time;
          this.tourState.selectedHour = parseInt(timeBtn.dataset.hour);
          this.tourState.selectedMinute = parseInt(timeBtn.dataset.minute);
          this.saveTourDraft();
          
          // Update UI
          container.querySelectorAll('.time__slot').forEach(t => t.classList.remove('time__slot--selected'));
          timeBtn.classList.add('time__slot--selected');
          
          // Enable next button
          document.querySelector('.tour-next').disabled = false;
        });
      });
      
    } catch (error) {
      console.error('Failed to load availability:', error);
      container.innerHTML = `
        <div class="tour-form">
          <h3>Choose your preferred time</h3>
          <p style="color: var(--text-secondary);">Unable to load availability. Please try again.</p>
          <button class="btn btn--secondary" onclick="RFCEApp.renderTimeStep(document.querySelector('.tour-step-content'))">Retry</button>
        </div>
      `;
    }
  },

  renderDetailsStep(container) {
    container.innerHTML = `
      <div class="tour-form">
        <h3>Your Contact Information</h3>
        
        <div class="form-group">
          <label class="form-label">I'm inquiring for:</label>
          <div class="tour-radio-group">
            <label class="tour-radio">
              <input type="radio" name="inquiringFor" value="self" ${this.tourState.details.for === 'self' ? 'checked' : ''}>
              Self
            </label>
            <label class="tour-radio">
              <input type="radio" name="inquiringFor" value="loved-one" ${this.tourState.details.for === 'loved-one' ? 'checked' : ''}>
              Loved One
            </label>
          </div>
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label class="form-label">Full Name *</label>
            <input type="text" class="form-input" name="name" value="${this.tourState.details.name}" required>
            <div class="form-error">Please enter your full name</div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Email Address *</label>
            <input type="email" class="form-input" name="email" value="${this.tourState.details.email}" required>
            <div class="form-error">Please enter a valid email address</div>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Phone Number *</label>
          <input type="tel" class="form-input" name="phone" value="${this.tourState.details.phone}" required>
          <div class="form-error">Please enter your phone number</div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Additional Notes (Optional)</label>
          <textarea class="form-input" name="notes" rows="3" placeholder="Any specific questions or requirements?">${this.tourState.details.notes}</textarea>
        </div>
      </div>
    `;
    
    // Bind form events
    const inputs = container.querySelectorAll('input, textarea');
    inputs.forEach(input => {
      input.addEventListener('input', () => {
        this.updateTourDetails();
        this.validateTourField(input);
        document.querySelector('.tour-next').disabled = !this.validateDetails();
      });
      
      input.addEventListener('blur', () => {
        this.validateTourField(input);
      });
    });
    
    // Radio buttons
    container.querySelectorAll('input[name="inquiringFor"]').forEach(radio => {
      radio.addEventListener('change', () => {
        this.tourState.details.for = radio.value;
        this.saveTourDraft();
      });
    });
  },

  renderConfirmStep(container) {
    const date = new Date(this.tourState.date);
    const timeDisplay = this.formatTime12Hour(...this.tourState.time.split(':'));
    
    container.innerHTML = `
      <div class="tour-form">
        <h3>Confirm Your Tour</h3>
        
        <div class="tour-summary">
          <h3>Tour Details</h3>
          <div class="tour-summary-item">
            <div class="tour-summary-label">Date & Time</div>
            <div class="tour-summary-value">${this.formatDateLong(date)} at ${timeDisplay}</div>
          </div>
          <div class="tour-summary-item">
            <div class="tour-summary-label">Name</div>
            <div class="tour-summary-value">${this.tourState.details.name}</div>
          </div>
          <div class="tour-summary-item">
            <div class="tour-summary-label">Email</div>
            <div class="tour-summary-value">${this.tourState.details.email}</div>
          </div>
          <div class="tour-summary-item">
            <div class="tour-summary-label">Phone</div>
            <div class="tour-summary-value">${this.tourState.details.phone}</div>
          </div>
          ${this.tourState.details.notes ? `
            <div class="tour-summary-item">
              <div class="tour-summary-label">Notes</div>
              <div class="tour-summary-value">${this.tourState.details.notes}</div>
            </div>
          ` : ''}
        </div>
        
        <div class="tour-actions">
          <button class="btn btn-primary" onclick="RFCEApp.bookTour()" id="book-tour-btn">Book Tour</button>
          <button class="btn btn--secondary" onclick="RFCEApp.downloadICS()">Download Calendar Event</button>
          <button class="btn btn--ghost" onclick="RFCEApp.copyTourDetails()">Copy Details</button>
        </div>
        
        <div class="tour-booking-error" style="display: none; color: var(--text-error, #d32f2f); margin-top: var(--space-md); padding: var(--space-sm); background: rgba(211, 47, 47, 0.1); border-radius: var(--border-radius); text-align: center;"></div>
      </div>
    `;
  },

  // Helper methods
  updateTourDetails() {
    const container = document.querySelector('.tour-step-content');
    this.tourState.details.name = container.querySelector('[name="name"]')?.value || '';
    this.tourState.details.email = container.querySelector('[name="email"]')?.value || '';
    this.tourState.details.phone = container.querySelector('[name="phone"]')?.value || '';
    this.tourState.details.notes = container.querySelector('[name="notes"]')?.value || '';
    this.saveTourDraft();
  },

  validateTourField(field) {
    const group = field.closest('.form-group');
    let isValid = true;
    
    if (field.required && !field.value.trim()) {
      isValid = false;
    } else if (field.type === 'email' && field.value) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      isValid = emailRegex.test(field.value);
    }
    
    group.classList.toggle('error', !isValid);
    return isValid;
  },

  validateDetails() {
    const { name, email, phone } = this.tourState.details;
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    return name.trim() && 
           email.trim() && emailRegex.test(email) && 
           phone.trim();
  },

  async bookTour() {
    const bookBtn = document.querySelector('#book-tour-btn');
    const errorDiv = document.querySelector('.tour-booking-error');
    
    if (!bookBtn) return;
    
    // Disable button and show loading
    bookBtn.disabled = true;
    bookBtn.textContent = 'Booking...';
    errorDiv.style.display = 'none';
    
    try {
      const dateObj = new Date(this.tourState.date);
      const hour = this.tourState.selectedHour || parseInt(this.tourState.time.split(':')[0]);
      const minute = this.tourState.selectedMinute || parseInt(this.tourState.time.split(':')[1]);
      
      await TourScheduler.tryBook({
        dateObj,
        hour,
        minute,
        name: this.tourState.details.name,
        email: this.tourState.details.email,
        phone: this.tourState.details.phone,
        note: this.tourState.details.notes
      });
      
      // Success! Store for UX and show success state
      localStorage.setItem('tourSelection', JSON.stringify({
        date: this.tourState.date,
        time: this.tourState.time
      }));
      
      // Show success state
      this.showTourSuccess();
      
    } catch (error) {
      console.error('Booking failed:', error);
      
      if (error.message === 'This time was just booked.') {
        // Show conflict error and go back to time step
        errorDiv.textContent = 'That time was just taken. Please pick another.';
        errorDiv.style.display = 'block';
        
        setTimeout(() => {
          this.tourState.step = 2;
          this.tourState.time = null;
          this.tourState.selectedHour = null;
          this.tourState.selectedMinute = null;
          this.renderTourStep();
        }, 2000);
      } else {
        // Show generic error
        errorDiv.textContent = 'Booking failed. Please try again or contact us directly.';
        errorDiv.style.display = 'block';
        bookBtn.disabled = false;
        bookBtn.textContent = 'Book Tour';
      }
    }
  },
  
  showTourSuccess() {
    const content = document.querySelector('.tour-step-content');
    const date = new Date(this.tourState.date);
    const timeDisplay = this.formatTime12Hour(...this.tourState.time.split(':'));
    
    content.innerHTML = `
      <div class="tour-form" style="text-align: center;">
        <div style="color: var(--brand); font-size: 3rem; margin-bottom: var(--space-md);">✓</div>
        <h3 style="color: var(--brand);">Tour Booked Successfully!</h3>
        <p style="margin: var(--space-md) 0;">Your tour has been confirmed for:</p>
        <div style="background: var(--bg-light); padding: var(--space-md); border-radius: var(--border-radius); margin: var(--space-lg) 0;">
          <strong>${this.formatDateLong(date)} at ${timeDisplay}</strong>
        </div>
        <p style="color: var(--text-secondary); margin-bottom: var(--space-lg);">We'll send you a confirmation email shortly with all the details.</p>
        
        <div class="tour-actions">
          <button class="btn btn-primary" onclick="RFCEApp.finishTourBooking()">Close</button>
          <button class="btn btn--secondary" onclick="RFCEApp.downloadICS()">Download Calendar Event</button>
        </div>
      </div>
    `;
  },
  
  finishTourBooking() {
    this.closeTourModal();
    this.resetTourState();
    this.showToast('Tour booked successfully! We\'ll be in touch soon.');
  },
  
  resetTourState() {
    this.tourState = {
      step: 1,
      date: null,
      time: null,
      selectedHour: null,
      selectedMinute: null,
      details: {
        name: '',
        email: '',
        phone: '',
        notes: '',
        for: 'self'
      }
    };
    localStorage.removeItem('tourDraft');
  },

  saveAndGoToContact() {
    // This method now only handles UX prefilling, not actual booking
    // Store selection for UX convenience only
    this.prefillContactForm();
    this.closeTourModal();
    
    // Navigate to contact page if not already there
    if (!window.location.pathname.includes('contact.html')) {
      window.location.href = './contact.html';
    }
    
    // Clear tour draft
    localStorage.removeItem('tourDraft');
    this.showToast('Tour details saved for contact form.');
  },

  prefillContactForm() {
    // Show the tour summary container
    const summaryContainer = document.querySelector('#tour-summary-container');
    const summaryChip = document.querySelector('#tour-summary-chip');
    const hiddenDate = document.querySelector('#preferred_date');
    const hiddenTime = document.querySelector('#preferred_time');
    
    if (summaryContainer && summaryChip && hiddenDate && hiddenTime) {
      const date = new Date(this.tourState.date);
      const timeDisplay = this.formatTime12Hour(...this.tourState.time.split(':'));
      
      // Set hidden input values
      hiddenDate.value = this.tourState.date;
      hiddenTime.value = this.tourState.time;
      
      // Create summary chip with remove button
      summaryChip.innerHTML = `
        Tour scheduled: ${this.formatDateLong(date)} at ${timeDisplay}
        <button type="button" class="tour-summary-chip-remove" onclick="RFCEApp.removeTourSummary()" aria-label="Remove tour booking">×</button>
      `;
      
      // Show the container
      summaryContainer.style.display = 'block';
    }
    
    // Pre-fill form fields
    const form = document.querySelector('.contact-form');
    if (!form) return;
    
    const nameField = form.querySelector('#name');
    const emailField = form.querySelector('#email');
    const phoneField = form.querySelector('#phone');
    const messageField = form.querySelector('#message');
    
    if (nameField && !nameField.value) nameField.value = this.tourState.details.name;
    if (emailField && !emailField.value) emailField.value = this.tourState.details.email;
    if (phoneField && !phoneField.value) phoneField.value = this.tourState.details.phone;
    
    if (messageField && !messageField.value) {
      const date = new Date(this.tourState.date);
      const timeDisplay = this.formatTime12Hour(...this.tourState.time.split(':'));
      const tourInfo = `I have scheduled a tour for ${this.formatDateLong(date)} at ${timeDisplay}. ${this.tourState.details.notes ? this.tourState.details.notes : ''}`;
      messageField.value = tourInfo.trim();
    }
    
    // Focus first visible field
    setTimeout(() => {
      if (nameField && !nameField.value) nameField.focus();
      else if (messageField) messageField.focus();
    }, 100);
  },

  downloadICS() {
    const date = new Date(this.tourState.date);
    const [hours, minutes] = this.tourState.time.split(':').map(Number);
    
    // Set start time
    const startTime = new Date(date);
    startTime.setHours(hours, minutes, 0, 0);
    
    // Set end time (45 minutes later)
    const endTime = new Date(startTime);
    endTime.setMinutes(endTime.getMinutes() + 45);
    
    const icsContent = [
      'BEGIN:VCALENDAR',
      'VERSION:2.0',
      'PRODID:-//RFCE//Tour Scheduler//EN',
      'BEGIN:VEVENT',
      `DTSTART:${this.formatDateTimeISO(startTime)}`,
      `DTEND:${this.formatDateTimeISO(endTime)}`,
      'SUMMARY:Tour at RFCE Senior Living Community',
      'DESCRIPTION:Scheduled tour of RFCE Senior Living Community facilities and amenities.',
      'LOCATION:RFCE Senior Living Community\\, 123 Senior Living Lane\\, Wellness City\\, WC 12345',
      `ORGANIZER:mailto:tours@rfce.com`,
      `ATTENDEE:mailto:${this.tourState.details.email}`,
      'STATUS:CONFIRMED',
      'END:VEVENT',
      'END:VCALENDAR'
    ].join('\r\n');
    
    const blob = new Blob([icsContent], { type: 'text/calendar' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'rfce-tour.ics';
    a.click();
    URL.revokeObjectURL(url);
    
    this.showToast('Calendar event downloaded!');
  },

  copyTourDetails() {
    const date = new Date(this.tourState.date);
    const timeDisplay = this.formatTime12Hour(...this.tourState.time.split(':'));
    
    const details = [
      'RFCE Tour Details:',
      '',
      `Date: ${this.formatDateLong(date)}`,
      `Time: ${timeDisplay}`,
      `Name: ${this.tourState.details.name}`,
      `Email: ${this.tourState.details.email}`,
      `Phone: ${this.tourState.details.phone}`,
      this.tourState.details.notes ? `Notes: ${this.tourState.details.notes}` : '',
      '',
      'RFCE Senior Living Community',
      '123 Senior Living Lane',
      'Wellness City, WC 12345',
      'Phone: (555) 123-4567'
    ].filter(line => line !== '').join('\n');
    
    navigator.clipboard.writeText(details).then(() => {
      this.showToast('Details copied to clipboard!');
    }).catch(() => {
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = details;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      this.showToast('Details copied to clipboard!');
    });
  },

  removeTourSummary() {
    const summaryContainer = document.querySelector('#tour-summary-container');
    const hiddenDate = document.querySelector('#preferred_date');
    const hiddenTime = document.querySelector('#preferred_time');
    
    if (summaryContainer) {
      summaryContainer.style.display = 'none';
    }
    
    if (hiddenDate) hiddenDate.value = '';
    if (hiddenTime) hiddenTime.value = '';
    
    // Clear the message field tour info
    const messageField = document.querySelector('#message');
    if (messageField && messageField.value.includes('I have scheduled a tour')) {
      messageField.value = '';
    }
    
    this.showToast('Tour booking removed');
  },

  saveTourDraft() {
    localStorage.setItem('tourDraft', JSON.stringify(this.tourState));
  },

  restoreTourDraft() {
    const draft = localStorage.getItem('tourDraft');
    if (draft) {
      try {
        const parsed = JSON.parse(draft);
        this.tourState = { ...this.tourState, ...parsed };
      } catch (e) {
        // Invalid draft, ignore
      }
    }
  },

  // Date/Time formatting helpers
  formatMonthYear(date) {
    return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  },

  formatDateLong(date) {
    return date.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
  },

  formatDateISO(date) {
    return date.toISOString().split('T')[0];
  },

  formatDateTimeISO(date) {
    return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
  },

  formatTime12Hour(hours, minutes) {
    const period = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours > 12 ? hours - 12 : hours === 0 ? 12 : hours;
    return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
  },

  isSameDay(date1, date2) {
    return date1.toDateString() === date2.toDateString();
  },

  // Focus management helpers
  trapFocus(element) {
    const focusableElements = element.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    // Focus first element
    firstElement.focus();
    
    const trapHandler = (e) => {
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          if (document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          }
        } else {
          if (document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      }
    };
    
    element.addEventListener('keydown', trapHandler);
    this.focusTrapHandler = trapHandler;
    this.focusTrapElement = element;
  },

  releaseFocus() {
    if (this.focusTrapElement && this.focusTrapHandler) {
      this.focusTrapElement.removeEventListener('keydown', this.focusTrapHandler);
      this.focusTrapHandler = null;
      this.focusTrapElement = null;
    }
  }
};

// ===== Supabase DataService (front-end only) =====
// Helper function for image URLs with fallback
function imageURL(path) {
  return path ? `${SUPABASE_URL}/storage/v1/object/public/images/${path}` : './assets/img/fallback.jpg';
}

const DataService = {
  // Auth
  signIn(email, password){ return supa.auth.signInWithPassword({ email, password }); },
  signOut(){ return supa.auth.signOut(); },
  async isAdmin(){ const { data } = await supa.rpc('is_admin'); return !!data; },

  // Posts
  async listPosts(params = {}){
    let query = supa.from('posts')
      .select('id,slug,title,excerpt,cover_path,tags,published_at,status')
      .eq('status','published');
    
    // Sort by published_at desc, fallback to created_at desc
    query = query.order('published_at', { ascending: false })
                 .order('created_at', { ascending: false, nullsFirst: false });
    
    if (params.tag && params.tag !== 'all') {
      query = query.contains('tags', [params.tag]);
    }
    
    if (params.limit) {
      query = query.limit(params.limit);
    }
    
    if (params.offset) {
      query = query.range(params.offset, params.offset + (params.limit || 50) - 1);
    }
    
    const { data, error } = await query;
    if (error) throw error; 
    return data||[];
  },

  // Images (DB + Storage)
  async listImages(params){
    let query = supa.from('images').select('*').order('created_at',{descending:true});
    if (params?.category) {
      query = query.eq('category', params.category);
    }
    const { data, error } = await query;
    if (error) throw error; return data||[];
  },
  async uploadImage(file, alt='', meta){
    const safe = file.name.replace(/\s+/g,'_');
    const category = meta?.category || 'gallery';
    let tags = Array.isArray(meta?.tags) ? meta.tags : [];
    
    // Add default tags for gallery images if none provided
    if (category === 'gallery' && tags.length === 0) {
      // Add a random default tag for testing filters
      const defaultTags = ['community', 'places', 'wellness', 'dining', 'nature'];
      const randomTag = defaultTags[Math.floor(Math.random() * defaultTags.length)];
      tags = [randomTag];
    }
    
    // Scope-based storage path
    const storagePath = `${category}/${Date.now()}_${safe}`;
    
    console.log('🔍 DataService.uploadImage ANTI-DUPLICATION MODE:', {
      selectedScope: category,
      storagePath,
      insertTable: 'images',
      noPostsWrite: true,
      strict: 'GALLERY_BLOG_SEPARATION'
    });
    
    // ANTI-DUPLICATION SAFEGUARD: Block any accidental post creation
    if (category !== 'gallery' && category !== 'blog') {
      throw new Error(`Invalid category: ${category}. Must be 'gallery' or 'blog'`);
    }
    
    const up = await supa.storage.from('images').upload(storagePath, file, { cacheControl:'3600' });
    if (up.error) throw up.error;
    
    // Insert ONLY into images table - ABSOLUTELY NO posts table writes
    const insertResult = await supa.from('images').insert({ 
      path: storagePath, 
      alt, 
      category, 
      tags 
    });
    
    if (insertResult.error) {
      console.error('❌ Image insert failed:', insertResult.error);
      throw insertResult.error;
    }
    
    const { data: { publicUrl } } = supa.storage.from('images').getPublicUrl(storagePath);
    
    console.log('✅ Upload complete - ZERO posts affected:', {
      path: storagePath,
      category,
      publicUrl,
      postsTableUntouched: true
    });
    return { path: storagePath, publicUrl };
  },
  async deleteImage(id){
    // Get image details
    const { data: image, error: fetchError } = await supa.from('images').select('path, category').eq('id', id).single();
    if (fetchError) throw fetchError;
    
    // For gallery images, check if any posts reference this image
    if (image.category === 'gallery') {
      const { data: posts, error: postsError } = await supa.from('posts').select('id').eq('image_path', image.path);
      if (postsError) throw postsError;
      
      if (posts && posts.length > 0) {
        throw new Error('Cannot delete gallery image: it is referenced by blog posts');
      }
    }
    
    // Delete from storage
    const { error: storageError } = await supa.storage.from('images').remove([image.path]);
    if (storageError) throw storageError;
    
    // Delete from database
    const { error: dbError } = await supa.from('images').delete().eq('id', id);
    if (dbError) throw dbError;
    
    return true;
  },
  

  // Leads
  async createLead(lead) { 
    const { error } = await supa.from('leads').insert(lead); 
    if (error) throw error; 
    
    // Send email notification (non-blocking)
    try {
      await supa.functions.invoke('notify-lead', { body: lead });
    } catch (emailError) {
      console.error('Email notification failed:', emailError);
      // Don't throw - the lead was saved successfully
    }
    
    return true; 
  },

  // Tour Slots
  async getBookedSlotsForDay(dateObj){
    const startOfDayUTC = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate()).toISOString();
    const endOfDayUTC = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1).toISOString();
    const { data, error } = await supa.from('tour_slots')
      .select('slot')
      .gte('slot', startOfDayUTC)
      .lt('slot', endOfDayUTC);
    if (error) throw error;
    return (data || []).map(row => {
      const localTime = new Date(row.slot);
      return `${localTime.getHours().toString().padStart(2, '0')}:${localTime.getMinutes().toString().padStart(2, '0')}`;
    });
  },

  async tryBook({dateObj, hour, minute, name, email, phone, note}){
    const slotISO = TourScheduler.buildLocalSlotISO(dateObj, hour, minute);
    const { error } = await supa.from('tour_slots').insert({ 
      slot: slotISO, 
      name, 
      email, 
      phone, 
      note 
    });
    
    if (error) {
      if (error.code === '23505' || error.details?.includes('duplicate') || error.message?.includes('duplicate')) {
        throw new Error('This time was just booked.');
      }
      throw error;
    }
    
    // Also create a lead entry
    const dateStr = dateObj.toISOString().split('T')[0];
    const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    await this.createLead({ 
      name, 
      email, 
      phone, 
      message: note || 'Tour booking', 
      source: 'tour',
      preferred_date: dateStr,
      preferred_time: timeStr
    });
    
    return true;
  },

  // Settings
  async getSettings(){ const { data } = await supa.from('settings').select('*').eq('id',1).maybeSingle(); return data||{}; },

  // Image URL helper with caching
  _imageUrlCache: new Map(),
  imagePublicURL(path) {
    if (!path) return null;
    if (this._imageUrlCache.has(path)) {
      return this._imageUrlCache.get(path);
    }
    const { data: { publicUrl } } = supa.storage.from('images').getPublicUrl(path);
    this._imageUrlCache.set(path, publicUrl);
    return publicUrl;
  }
};

// ===== Tour Scheduler Module =====
const TourScheduler = {
  buildLocalSlotISO(dateObj, hour, minute = 0) {
    const localDateTime = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), hour, minute);
    return localDateTime.toISOString();
  },

  async getBookedSlotsForDay(dateObj) {
    return await DataService.getBookedSlotsForDay(dateObj);
  },

  generateTimes() {
    const times = [];
    for (let hour = 9; hour <= 17; hour++) {
      times.push({
        value: `${hour.toString().padStart(2, '0')}:00`,
        display: this.formatTime12Hour(hour, 0),
        hour,
        minute: 0
      });
    }
    return times;
  },

  formatTime12Hour(hours, minutes) {
    const period = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours > 12 ? hours - 12 : hours === 0 ? 12 : hours;
    return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
  },

  paintAvailability(container, disabledList, selectedTime) {
    const times = this.generateTimes();
    
    const timesHTML = times.map(time => {
      const isDisabled = disabledList.includes(time.value);
      const isSelected = selectedTime === time.value;
      
      let classes = ['time__slot'];
      if (isSelected) classes.push('time__slot--selected');
      if (isDisabled) classes.push('time__slot--disabled');
      
      return `
        <button class="${classes.join(' ')}" 
                data-time="${time.value}" 
                data-hour="${time.hour}"
                data-minute="${time.minute}"
                ${isDisabled ? 'disabled aria-disabled="true" title="Unavailable"' : ''}>
          ${time.display}
        </button>
      `;
    }).join('');
    
    container.querySelector('.times').innerHTML = timesHTML;
  },

  async tryBook({dateObj, hour, minute, name, email, phone, note}) {
    return await DataService.tryBook({dateObj, hour, minute, name, email, phone, note});
  }
};

// ===== Page initializers =====
    console.log('📝 Blog: Loading blog posts from Supabase');
    console.log('📝 Blog: Grid element:', grid);
    
    try {
      // First, let's check if we can access the posts table at all
      const { data: allPosts, error: allError } = await supa.from('posts').select('*');
      console.log('📝 Blog: All posts in database:', allPosts);
      console.log('📝 Blog: All posts error:', allError);
      
      const { data: posts, error } = await supa.from('posts')
        .select('id, title, tags, body, image_path, status, published_at')
        .eq('status', 'published')
        .order('published_at', { ascending: false });
      
      if (error) {
        console.error('❌ Error loading posts:', error);
        grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin: 2rem 0;">Error loading blog posts. Please try again.</p>';
        return;
      }
      
      console.log(`📝 Blog: Found ${posts.length} published posts`);
      console.log('📝 Blog: Published posts data:', posts);
      
      // Add default tags to posts that don't have any (for existing posts)
      const postsWithTags = posts.map(post => {
        if (!Array.isArray(post.tags) || post.tags.length === 0) {
          const defaultTags = ['wellness', 'lifestyle', 'community', 'nutrition', 'education', 'family', 'safety'];
          const randomTag = defaultTags[Math.floor(Math.random() * defaultTags.length)];
          return { ...post, tags: [randomTag] };
        }
        return post;
      });
      
      allImages = postsWithTags || [];
      
      // If no posts exist, create a test post to verify the system works
      if (allImages.length === 0) {
        console.log('📝 Blog: No posts found, creating a test post');
        try {
          const testPost = {
            title: 'Welcome to RFCE Blog',
            tags: ['community'],
            body: 'This is a test blog post to verify that the blog system is working correctly. You can create your own posts through the admin panel.',
            image_path: 'blog/test-image.jpg', // This will show a fallback image
            status: 'published',
            published_at: new Date().toISOString()
          };
          
          const { error: testError } = await supa.from('posts').insert(testPost);
          if (testError) {
            console.error('❌ Test post creation failed:', testError);
          } else {
            console.log('✅ Test post created successfully');
            // Refresh to show the test post
            setTimeout(() => refreshBlog(), 1000);
            return;
          }
        } catch (testErr) {
          console.error('❌ Test post creation exception:', testErr);
        }
      }
    
    // Clear grid before each render to avoid stale DOM cards
    grid.innerHTML = '';
    
    if (postList.length === 0) {
      let message = 'No blog posts found.';
      if (state.tag !== 'all' || state.query) {
        message = 'No blog posts found matching your search criteria. Try adjusting your filters or search terms.';
      } else {
        message = 'No blog posts found. Create posts in the admin panel to see them here.';
      }
      console.log('📝 Blog: No posts to render, showing message:', message);
      grid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); margin: 2rem 0;">${message}</p>`;
      return;
    }
    
    const cards = postList.map(post => {
      console.log('📝 Blog: Processing post for rendering:', post);
      
      const url = supa.storage.from('images').getPublicUrl(post.image_path).data.publicUrl;
      const date = formatDate(post.published_at);
      
      // Create tags HTML from admin-entered tags
      const tags = Array.isArray(post.tags) && post.tags.length > 0 
        ? post.tags.map(tag => `<span class="tag">${tag}</span>`).join('') 
        : '';
      
      // Create excerpt from admin-entered body (first ~160 chars, HTML stripped)
      const excerpt = post.body 
        ? post.body.replace(/<[^>]*>/g, '').substring(0, 160) + (post.body.length > 160 ? '...' : '')
        : 'No content available';
      
      const cardHTML = `<article class="post-card" data-post-id="${post.id}">
        <img class="post-card__img" src="${url}" alt="${post.title}" loading="lazy" onerror="this.src='./assets/img/fallback.jpg'">
        <div class="post-card__body">
          <div class="post-card__meta">
            ${date ? `${date} ` : ''}${tags}
          </div>
          <h3 class="post-card__title">${post.title || 'Untitled'}</h3>
          <p class="post-card__excerpt">${excerpt}</p>
        </div>
      </article>`;
      
      console.log('📝 Blog: Generated card HTML:', cardHTML);
      return cardHTML;
    });
    
    console.log('📝 Blog: Generated cards count:', cards.length);
    console.log('📝 Blog: Setting grid innerHTML');
    grid.innerHTML = cards.join('');
    console.log('📝 Blog: Grid innerHTML set, content length:', grid.innerHTML.length);
  }
  
  async function filterAndRender() {
    let filtered = allImages;
    
    console.log('📝 Blog: Filtering posts - tag:', state.tag, 'query:', state.query);
    console.log('📝 Blog: Total posts before filtering:', filtered.length);
    
    // Apply tag filter
    if (state.tag !== 'all') {
      filtered = filtered.filter(post => {
        if (!Array.isArray(post.tags) || post.tags.length === 0) {
          console.log(`📝 Blog: Post ${post.id} has no tags`);
          return false;
        }
        
        const hasTag = post.tags.some(tag => 
          tag.toLowerCase() === state.tag.toLowerCase()
        );
        console.log(`📝 Blog: Post ${post.id} tags:`, post.tags, 'has tag', state.tag, ':', hasTag);
        return hasTag;
      });
    }
    
    // Apply search filter
    if (state.query) {
      filtered = filtered.filter(post => {
        const title = (post.title || '').toLowerCase();
        const body = (post.body || '').toLowerCase();
        const searchQuery = state.query.toLowerCase();
        const matches = title.includes(searchQuery) || body.includes(searchQuery);
        console.log(`📝 Blog: Post ${post.id} search match:`, matches, 'title:', title, 'body:', body.substring(0, 50) + '...');
        return matches;
      });
    }
    
    console.log('📝 Blog: Filtered posts count:', filtered.length);
    await render(filtered);
  }
  
  // Delegated click listener for opening posts
  grid.addEventListener('click', (e) => {
    const card = e.target.closest('[data-post-id]');
    if (card) {
      const postId = card.dataset.postId;
      openPostModal(postId);
    }
  });
  
  // Function to open post modal
  async function openPostModal(postId) {
    const post = allImages.find(p => p.id == postId);
    if (!post) return;
    
    const modal = document.querySelector('[data-post-modal]');
    const dialog = document.querySelector('[data-post-dialog]');
    const title = document.getElementById('post-modal-title');
    const meta = document.querySelector('.post-modal__meta');
    const content = document.querySelector('[data-post-content]');
    
    if (!modal || !dialog || !title || !meta || !content) return;
    
    const url = supa.storage.from('images').getPublicUrl(post.image_path).data.publicUrl;
    const date = formatDate(post.published_at);
    
    // Create tags HTML from admin-entered tags
    const tags = Array.isArray(post.tags) && post.tags.length > 0 
      ? post.tags.map(tag => `<span class="tag">${tag}</span>`).join('') 
      : '';
    
    title.textContent = post.title || 'Untitled';
    meta.innerHTML = `${date ? `${date} ` : ''}${tags}`;
    
    content.innerHTML = `
      <img class="post-modal__cover" src="${url}" alt="${post.title}" style="width: 100%; max-width: 100%; height: auto; border-radius: 8px; margin-bottom: 1rem;">
      <div style="white-space: pre-wrap;">${post.body || 'No content available'}</div>
    `;
    
    modal.hidden = false;
    dialog.focus();
  }
  
  // Modal functionality
  const modal = document.querySelector('[data-post-modal]');
  const dialog = document.querySelector('[data-post-dialog]');
  const closeBtn = document.querySelector('[data-post-close]');
  const title = document.querySelector('#post-modal-title');
  const meta = document.querySelector('.post-modal__meta');
  const content = document.querySelector('[data-post-content]');
  
  // Modal close functionality
  function closeModal() {
    modal.hidden = true;
  }
  
  // Modal event listeners
  if (modal && closeBtn) {
    // Close button
    closeBtn.addEventListener('click', closeModal);
    
    // Backdrop click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });
    
    // Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !modal.hidden) {
        closeModal();
      }
    });
    
    // Handle browser back/forward
    window.addEventListener('popstate', () => {
      if (!window.location.search.includes('post=') && !modal.hidden) {
        modal.hidden = true;
        releaseFocus();
      }
    });
    
    // Check for deep link on load
    const urlParams = new URLSearchParams(window.location.search);
    const postSlug = urlParams.get('post');
    if (postSlug) {
      // Delay to ensure posts are loaded
      setTimeout(() => openModal(postSlug), 100);
    }
  }
  
  // Focus management utilities
  let focusTrapHandler = null;
  let focusTrapElement = null;
  
  function trapFocus(element) {
    const focusableElements = element.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    const trapHandler = (e) => {
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          if (document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          }
        } else {
          if (document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      }
    };
    
    element.addEventListener('keydown', trapHandler);
    focusTrapHandler = trapHandler;
    focusTrapElement = element;
  }
  
  function releaseFocus() {
    if (focusTrapElement && focusTrapHandler) {
      focusTrapElement.removeEventListener('keydown', focusTrapHandler);
      focusTrapHandler = null;
      focusTrapElement = null;
    }
  }
  
  // Wire tag filters
  const bar = document.querySelector('[data-blog-filters]');
  if (bar && !bar.dataset.initialized){
    bar.dataset.initialized = 'true'; // Prevent duplicate listeners
    bar.addEventListener('click', async (e)=>{
      const btn = e.target.closest('[data-tag]'); if(!btn) return;
      bar.querySelectorAll('.chip').forEach(c=>c.classList.remove('chip--active'));
      btn.classList.add('chip--active');
      state.tag = btn.dataset.tag;
      await filterAndRender();
    });
  }
  
  // Wire search with debounce
  const search = document.querySelector('[data-blog-search]');
  const wrap = document.querySelector('[data-blog-search-wrap]');
  const clearBtn = wrap?.querySelector('[data-search-clear]');
  
  if (search && wrap && !wrap.dataset.setup) {
    wrap.dataset.setup = 'true';
    
    let debounceTimer;
    search.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      const value = e.target.value.trim();
      
      // Toggle clear button visibility
      if (clearBtn) {
        clearBtn.hidden = value === '';
      }
      
      debounceTimer = setTimeout(async () => {
        state.query = value.toLowerCase();
        await filterAndRender();
      }, 200);
    });
    
    // Wire clear button
    if (clearBtn) {
      clearBtn.addEventListener('click', async () => {
        search.value = '';
        state.query = '';
        clearBtn.hidden = true;
        await filterAndRender();
        search.focus();
      });
    }
  }
  
  // Search functionality with debouncing
  const searchInput = document.querySelector('[data-blog-search]');
  const searchClear = document.querySelector('[data-search-clear]');
  let searchTimeout;
  
  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      // Clear previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      // Debounce search to avoid too many API calls
      searchTimeout = setTimeout(() => {
        state.query = query;
        console.log('📝 Blog: Search query changed:', state.query);
        filterAndRender();
        
        // Show/hide clear button
        if (searchClear) {
          searchClear.hidden = !state.query;
        }
      }, 300); // 300ms delay
    });
  }
  
  if (searchClear) {
    searchClear.addEventListener('click', () => {
      if (searchInput) {
        searchInput.value = '';
        state.query = '';
        console.log('📝 Blog: Search cleared');
        filterAndRender();
        searchClear.hidden = true;
      }
    });
  }
  
  // Filter functionality
  const filterBar = document.querySelector('[data-blog-filters]');
  if (filterBar && !filterBar.dataset.initialized) {
    filterBar.dataset.initialized = 'true';
    console.log('📝 Blog: Setting up filters');
    
    filterBar.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-tag]');
      if (!btn) return;
      
      console.log('📝 Blog: Filter clicked:', btn.dataset.tag);
      
      // Update active state
      filterBar.querySelectorAll('.chip').forEach(c => c.classList.remove('chip--active'));
      btn.classList.add('chip--active');
      
      // Update state and filter
      state.tag = btn.dataset.tag;
      console.log('📝 Blog: Filtering by tag:', state.tag);
      filterAndRender();
    });
  }
  
  // Blog auto-refresh hook
  window.addEventListener('rfce-posts-updated', () => refreshBlog());
  window.addEventListener('rfce-images-updated', () => refreshBlog());
  
  // Initial fetch and render
  await refreshBlog();
}

async function initGallery(){
  if (!document.body.classList.contains('page-gallery')) return;
  const grid = document.querySelector('[data-gallery-grid]'); if (!grid) return;
  
  console.log('🖼️ Gallery: Loading gallery images from Supabase');
  let allImages = [];
  
  async function refreshGallery() {
    console.log('🖼️ Gallery: Refreshing images');
    try {
      const { data: images, error } = await supa.from('images')
        .select('id, path, alt, category, tags, created_at')
        .eq('category', 'gallery')
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('❌ Error loading gallery images:', error);
        grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin: 2rem 0;">Error loading gallery images. Please try again.</p>';
        return;
      }
      
      console.log(`🖼️ Gallery: Found ${images.length} gallery images`);
      
      // Add default tags to images that don't have any (for existing images)
      const imagesWithTags = images.map(img => {
        if (!Array.isArray(img.tags) || img.tags.length === 0) {
          const defaultTags = ['community', 'places', 'wellness', 'dining', 'nature'];
          const randomTag = defaultTags[Math.floor(Math.random() * defaultTags.length)];
          return { ...img, tags: [randomTag] };
        }
        return img;
      });
      
      allImages = imagesWithTags || [];
      render(allImages);
    } catch (err) {
      console.error('❌ Exception loading gallery images:', err);
      grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin: 2rem 0;">Error loading gallery images. Please try again.</p>';
    }
  }
  
  function render(list) {
    if (list.length === 0) {
      grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin: 2rem 0; grid-column: 1 / -1;">No images found for this filter. Try selecting a different category.</p>';
      return;
    }
    
    grid.innerHTML = list.map(i=>{
      const url = supa.storage.from('images').getPublicUrl(i.path).data.publicUrl;
      return `<a href="${url}" data-lightbox><img src="${url}" alt="${i.alt||''}" loading="lazy" onerror="this.src='assets/img/fallback.jpg'"></a>`;
    }).join('');
  }
  
  // Wire filters
  const bar = document.querySelector('[data-gallery-filters]');
  if (bar && !bar.dataset.initialized){
    bar.dataset.initialized = 'true'; // Prevent duplicate listeners
    console.log('🖼️ Gallery: Setting up filters');
    
    bar.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-filter]'); 
      if(!btn) return;
      
      console.log('🖼️ Gallery: Filter clicked:', btn.dataset.filter);
      
      // Update active state
      bar.querySelectorAll('.chip').forEach(c=>c.classList.remove('chip--active'));
      btn.classList.add('chip--active');
      
      const key = btn.dataset.filter;
      console.log('🖼️ Gallery: Filtering by:', key);
      console.log('🖼️ Gallery: Total images before filter:', allImages.length);
      
      // Filter images
      const list = key==='all'
        ? allImages
        : allImages.filter(i => {
            if (!Array.isArray(i.tags) || i.tags.length === 0) {
              console.log(`🖼️ Gallery: Image ${i.id} has no tags`);
              return false;
            }
            
            const hasTag = i.tags.some(tag => 
              tag.toLowerCase() === key.toLowerCase()
            );
            console.log(`🖼️ Gallery: Image ${i.id} tags:`, i.tags, 'has tag', key, ':', hasTag);
            return hasTag;
          });
      
      console.log('🖼️ Gallery: Filtered images count:', list.length);
      render(list);
    });
  }
  
  // Gallery auto-refresh hook
  window.addEventListener('rfce-images-updated', () => refreshGallery());
  
  // Initial load
  await refreshGallery();
}

function initContactForm(){
  const form = document.querySelector('[data-contact-form]'); if (!form) return;
  
  // Handle tour prefill from localStorage
  try {
    const saved = JSON.parse(localStorage.getItem('tourSelection')||'null');
    if (saved) {
      const d=document.createElement('input'); d.type='hidden'; d.name='preferred_date'; d.value=saved.date;
      const t=document.createElement('input'); t.type='hidden'; t.name='preferred_time'; t.value=saved.time;
      form.append(d,t);
    }
  } catch(_){}
  
  // Remove existing listeners to prevent duplicates
  if (form.dataset.initialized) return;
  form.dataset.initialized = 'true';
  
  form.addEventListener('submit', async (e)=>{
    e.preventDefault();
    
    // Validate form
    const inputs = form.querySelectorAll('.form-input, .form-textarea');
    let valid = true;
    
    inputs.forEach(input => {
      const group = input.closest('.form-group');
      const error = group.querySelector('.form-error');
      const inputName = input.getAttribute('name');
      const inputValue = input.value.trim();
      
      // Clear previous error state
      group.classList.remove('error');
      error.style.display = 'none';
      
      // Check required fields
      if (!inputValue && input.required) {
        group.classList.add('error');
        error.textContent = `${inputName} is required`;
        error.style.display = 'block';
        valid = false;
      }
      // Email validation
      else if (inputName === 'email' && inputValue && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(inputValue)) {
        group.classList.add('error');
        error.textContent = 'Please enter a valid email address';
        error.style.display = 'block';
        valid = false;
      }
      // Phone validation (optional but validate if provided)
      else if (inputName === 'phone' && inputValue && !/^[\d\s()+\-\.]{7,}$/.test(inputValue)) {
        group.classList.add('error');
        error.textContent = 'Please enter a valid phone number';
        error.style.display = 'block';
        valid = false;
      }
    });
    
    if (!valid) return;
    
    // Prepare payload
    const fd = new FormData(form);
    const phoneValue = (fd.get('phone')||'').toString().trim();
    const payload = {
      name:(fd.get('name')||'').toString().trim(),
      email:(fd.get('email')||'').toString().trim(),
      phone: phoneValue || null,
      message:(fd.get('message')||'').toString().trim(),
      source: fd.get('preferred_date') ? 'tour' : 'contact',
      preferred_date: fd.get('preferred_date')||null,
      preferred_time: fd.get('preferred_time')||null
    };
    
    // Disable submit button during processing
    const submitBtn = form.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    submitBtn.disabled = true;
    submitBtn.textContent = 'Sending...';
    
    try { 
      await DataService.createLead(payload); 
      RFCEApp.showToast('Thank you! Your message has been sent successfully. We\'ll get back to you soon.');
      form.reset();
      
      // Clear any tour summary if present
      const summaryContainer = document.querySelector('#tour-summary-container');
      if (summaryContainer) summaryContainer.style.display = 'none';
      
    } catch(err) { 
      console.error('Contact form error:', err);
      RFCEApp.showToast('Sorry, there was an error sending your message. Please try again or call us directly.', true);
    } finally {
      // Re-enable submit button
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  });
  
  // Clear errors on input
  form.querySelectorAll('.form-input, .form-textarea').forEach(input => {
    input.addEventListener('input', () => {
      const group = input.closest('.form-group');
      const error = group.querySelector('.form-error');
      
      // Always clear error state on input
      group.classList.remove('error');
      error.style.display = 'none';
      
      // Special handling for phone field - validate on input if not empty
      if (input.name === 'phone' && input.value.trim()) {
        const phoneValue = input.value.trim();
        if (phoneValue && !/^[\d\s()+\-\.]{7,}$/.test(phoneValue)) {
          group.classList.add('error');
          error.textContent = 'Please enter a valid phone number';
          error.style.display = 'block';
        }
      }
    });
  });
}

async function initAdmin(){
  if (!document.body.classList.contains('page-admin')) return;
  const login = document.querySelector('[data-admin-login]');
  const dash  = document.querySelector('[data-admin-dash]');
  
  // Helper function to set cover preview (removed)
  
  async function refresh(){
    const { data: { user } } = await supa.auth.getUser();
    const admin = user ? await DataService.isAdmin() : false;
    if (login) login.style.display = admin ? 'none' : '';
    if (dash)  dash.style.display  = admin ? '' : 'none';
    if (admin) {
      // Only load images if a destination is selected
      const selectedRadio = document.querySelector('input[name="imgDest"]:checked');
      if (selectedRadio) {
        loadAdminImages();
      } else {
        // Clear grid and show message to select destination
        const imgGrid = document.querySelector('[data-admin-images]');
        if (imgGrid) {
          imgGrid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin: 2rem 0;">Select a destination above to view images</p>';
        }
      }
    }
  }
  login?.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const fd = new FormData(login);
    const { error } = await DataService.signIn(fd.get('email'), fd.get('password'));
    if (error) return alert(error.message);
    if (!(await DataService.isAdmin())) { await DataService.signOut(); return alert('Not an admin'); }
    refresh();
  });
  document.querySelector('[data-admin-logout]')?.addEventListener('click', async ()=>{ await DataService.signOut(); refresh(); });

  // Clear all posts button
  document.querySelector('[data-clear-all-posts]')?.addEventListener('click', async () => {
    const confirmed = confirm('⚠️ WARNING: This will permanently delete ALL blog posts!\n\nThis action cannot be undone. Are you sure you want to proceed?');
    if (!confirmed) return;
    
    // Double confirmation for safety
    const doubleConfirmed = confirm('🚨 FINAL CONFIRMATION: Delete ALL blog posts?\n\nClick OK to delete everything, or Cancel to abort.');
    if (!doubleConfirmed) return;
    
    try {
      await DataService.deleteAllPosts();
      alert('✅ All blog posts have been deleted successfully!');
      
      // Notify blog page of changes
      window.dispatchEvent(new CustomEvent('rfce-posts-updated'));
    } catch (err) {
      console.error('❌ Failed to delete all posts:', err);
      alert('❌ Error: Failed to delete all posts. ' + (err.message || 'Unknown error'));
    }
  });
  
  // Auto-refresh admin images when radio selection changes
  document.querySelectorAll('input[name="imgDest"]').forEach(radio => {
    radio.addEventListener('change', () => {
      loadAdminImages();
    });
  });

  // Post form submit handler
  const postForm = document.querySelector('[data-admin-post]');
  
  // Initialize TagManager for the post form
  let tagManager = null;
  if (postForm) {
    const wrap = postForm.querySelector('[data-tags-input]');
    const entry = postForm.querySelector('[data-tags-entry]');
    const hidden = postForm.querySelector('[data-tags-hidden]');
    
    if (wrap && entry && hidden) {
      const tags = new Set();
      
      function render() {
        // Remove existing chips
        wrap.querySelectorAll('.tag-chip').forEach(chip => chip.remove());
        
        // Add chips for each tag
        Array.from(tags).forEach(tag => {
          const chip = document.createElement('div');
          chip.className = 'tag-chip';
          chip.dataset.value = tag;
          chip.innerHTML = `<span>${tag}</span><button type="button" class="tag-x" aria-label="Remove ${tag}">×</button>`;
          wrap.insertBefore(chip, entry);
        });
        
        // Ensure entry stays focused
        entry.focus();
      }
      
      function syncHidden() {
        hidden.value = Array.from(tags).join(',');
      }
      
      function add(value) {
        if (!value) return;
        // Split by comma or space, process each part
        const parts = value.split(/[,\s]+/);
        parts.forEach(part => {
          const trimmed = part.trim().toLowerCase();
          if (trimmed && trimmed.length > 0) {
            tags.add(trimmed);
          }
        });
        render();
        syncHidden();
      }
      
      function remove(value) {
        tags.delete(value);
        render();
        syncHidden();
      }
      
      // Entry field listeners
      entry.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ',') {
          e.preventDefault();
          add(entry.value);
          entry.value = '';
        } else if (e.key === 'Backspace' && entry.value === '') {
          const lastTag = Array.from(tags).pop();
          if (lastTag) remove(lastTag);
        }
      });
      
      entry.addEventListener('blur', () => {
        if (entry.value.trim()) {
          add(entry.value);
          entry.value = '';
        }
      });
      
      entry.addEventListener('paste', (e) => {
        e.preventDefault();
        const pastedText = (e.clipboardData || window.clipboardData).getData('text');
        add(pastedText);
        entry.value = '';
      });
      
      // Wrapper click listener for chip removal
      wrap.addEventListener('click', (e) => {
        if (e.target.classList.contains('tag-x')) {
          const chip = e.target.closest('.tag-chip');
          if (chip) {
            remove(chip.dataset.value);
          }
        }
      });
      
      tagManager = { add, remove, getTags: () => Array.from(tags) };
    }
  }
  // Helper function to generate slug from title
  function slugify(title) {
    return title
      .toLowerCase()
      .replace(/[\s_]+/g, '-')  // Replace spaces/underscores with '-'
      .replace(/[^a-z0-9-]/g, '')  // Remove non a-z, 0-9, or '-'
      .replace(/-+/g, '-')  // Collapse multiple '-'
      .replace(/^-+|-+$/g, '')  // Trim leading/trailing '-'
      .substring(0, 80);  // Limit to ~80 chars
  }
  
  // Helper function to generate excerpt from body HTML
  function generateExcerpt(body) {
    if (!body) return '';
    
    // Strip HTML tags and collapse whitespace
    const text = body
      .replace(/<[^>]*>/g, ' ')  // Remove HTML tags
      .replace(/\s+/g, ' ')     // Collapse multiple spaces
      .trim();
    
    // Take first 160 characters
    return text.length > 160 ? text.substring(0, 160).trim() + '...' : text;
  }
  
  // Helper function to ensure slug uniqueness
  async function ensureUniqueSlug(baseSlug) {
    let slug = baseSlug;
    let counter = 1;
    
    while (true) {
      try {
        // Check if slug exists in database
        const { data: existingPost } = await supa.from('posts')
          .select('id')
          .eq('slug', slug)
          .single();
        
        if (!existingPost) {
          // Slug is unique
          return slug;
        }
        
        // Slug exists, try with counter
        counter++;
        slug = `${baseSlug}-${counter}`;
      } catch (error) {
        // If error is 'PGRST116' (not found), slug is unique
        if (error.code === 'PGRST116') {
          return slug;
        }
        // For other errors, just return the current slug
        return slug;
      }
    }
  }
  postForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const fd = new FormData(postForm);
    const title = (fd.get('title') || '').toString().trim();
    
    // Title is now optional - removed client-side guard
    
    const body = (fd.get('body') || '').toString().trim();
    const tagsArray = tagManager ? tagManager.getTags() : [];
    
    // Auto-generate title from body if not provided
    let finalTitle = title;
    if (!finalTitle && body) {
      // Extract first sentence or first 50 characters
      const firstSentence = body.split(/[.!?]/)[0];
      finalTitle = firstSentence.substring(0, 50) + (firstSentence.length > 50 ? '...' : '');
    }
    
    // If still no title, use a default
    if (!finalTitle) {
      finalTitle = 'Untitled Post';
    }
    
    // Auto-generate slug from title and ensure uniqueness
    const baseSlug = slugify(finalTitle);
    const slug = await ensureUniqueSlug(baseSlug);
    
    // Auto-generate excerpt from body content
    const excerpt = generateExcerpt(body);
    
    // Get the most recently uploaded blog image as cover
    let coverPath = '';
    try {
      const blogImages = await DataService.listImages({ category: 'blog' });
      if (blogImages && blogImages.length > 0) {
        // Sort by created_at descending to get the most recent
        blogImages.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        coverPath = blogImages[0].path;
      }
    } catch (error) {
      console.error('Error fetching blog images for cover:', error);
    }
    
    // Build post object with all required fields
    const post = {
      title: finalTitle,
      slug,
      body: body || '',
      excerpt,
      tags: tagsArray,
      status: 'published',
      published_at: new Date().toISOString()
    };
    
    // Add cover image if available
    if (coverPath) {
      post.cover_path = coverPath;
    }
    
    try {
      await DataService.createPost(post);
      alert('Post created successfully!');
      postForm.reset();
      // Clear TagManager
      if (tagManager) {
        tagManager.getTags().forEach(tag => tagManager.remove(tag));
      }
      // Notify blog page of new post
      window.dispatchEvent(new CustomEvent('rfce-posts-updated'));
    } catch (err) {
      alert(err.message || 'Failed to create post');
    }
  });

  const fileInput = document.querySelector('#adminUpload');
  const imgGrid   = document.querySelector('[data-admin-images]');
  
  // Ensure single event listener (prevent duplicates)
  if (fileInput && !fileInput.dataset.uploadHandlerAttached) {
    fileInput.dataset.uploadHandlerAttached = 'true';
    
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      
      try {
        // Gallery only - no scope selection needed
        const selectedScope = 'gallery';
        
        console.log('🔒 DUPLICATION CHECK - Upload started:', {
          selectedScope,
          fileName: f.name,
          fileSize: f.size,
          expectedPath: `${selectedScope}/${Date.now()}_${f.name.replace(/\s+/g,'_')}`,
          willWriteToPostsTable: false,
          willDuplicate: false,
          strictMode: 'ANTI_DUPLICATION_ENABLED'
        });
        
        // TRIPLE-CHECK: Ensure no post creation during image upload
        const originalCreatePost = DataService.createPost;
        DataService.createPost = () => {
          console.error('❌ BLOCKED: Attempted post creation during image upload!');
          throw new Error('Post creation blocked during image upload');
        };
        
        try {
          // ANTI-DUPLICATION: Only write to images table with strict category
          const result = await DataService.uploadImage(f, f.name, { category: selectedScope });
          
          
          console.log('✅ Upload success - STRICT SEPARATION:', {
            storagePath: result.path,
            category: selectedScope,
            postsTableUntouched: true,
            galleryOnlyIfGallery: selectedScope === 'gallery',
            blogOnlyIfBlog: selectedScope === 'blog',
            noPostsCreated: true
          });
        } finally {
          // Restore original createPost method
          DataService.createPost = originalCreatePost;
        }
        
        // Refresh images grid to show new upload
        await loadAdminImages();
        
        // Notify pages of new image
        window.dispatchEvent(new CustomEvent('rfce-images-updated'));
        
        // Clear destination error if shown
        const destError = document.querySelector('#dest-error');
        if (destError) destError.style.display = 'none';
        
        // Show success toast with strict separation message
        const toast = document.createElement('div');
        toast.className = 'upload-toast';
        toast.innerHTML = `
          <div>✅ Uploaded to ${selectedScope.toUpperCase()} ONLY: ${f.name}</div>
          <div style="font-size:0.8em;margin-top:4px;color:rgba(255,255,255,0.8);">
            ⚠️ Will appear ONLY in ${selectedScope} section. No duplication to ${selectedScope === 'gallery' ? 'blog' : 'gallery'}.
          </div>
          <div style="font-size:0.7em;margin-top:2px;color:rgba(255,255,255,0.6);">
            🚨 ANTI-DUPLICATION: No posts created during upload
          </div>
        `;
        toast.style.cssText = `
          position:fixed;top:20px;right:20px;background:#4CAF50;color:white;
          padding:12px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.2);
          max-width:350px;z-index:1000;font-size:0.9em;
        `;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 5000);
        
      }
      catch(err){ 
        console.error('❌ Upload failed:', err);
        alert(err.message); 
      }
      e.target.value='';
    });
  }
  
  // Create Post button handler - only works when Blog is selected
  const createPostBtn = document.querySelector('[data-create-post]');
  if (createPostBtn && !createPostBtn.dataset.createPostHandlerAttached) {
    createPostBtn.dataset.createPostHandlerAttached = 'true';
    
    createPostBtn.addEventListener('click', async () => {
      const selectedRadio = document.querySelector('input[name="imgDest"]:checked');
      if (!selectedRadio || selectedRadio.value !== 'blog') {
        showToast('Please select "Blog" destination first', 'error');
        return;
      }

      // Check if there's an uploaded image
      const imagePreview = document.querySelector('[data-image-preview]');
      if (!imagePreview || !imagePreview.src || imagePreview.src.includes('placeholder')) {
        showToast('Please upload an image first', 'error');
        return;
      }

      // Get form data
      const titleInput = document.querySelector('#post-title');
      const tagsInput = document.querySelector('[data-tags-hidden]');
      const bodyInput = document.querySelector('#post-body');
      
      const title = titleInput ? titleInput.value.trim() : '';
      const tags = tagsInput ? (tagsInput.value ? tagsInput.value.split(',').map(t => t.trim()).filter(t => t).map(t => t.toLowerCase()) : []) : [];
      const body = bodyInput ? bodyInput.value.trim() : '';

      // Get the uploaded image path from the preview
      const imagePath = imagePreview.dataset.path;
      if (!imagePath) {
        showToast('Image path not found. Please upload the image again.', 'error');
        return;
      }

      try {
        // Add default tags if none provided
        let finalTags = tags;
        if (finalTags.length === 0) {
          const defaultTags = ['wellness', 'lifestyle', 'community', 'nutrition', 'education', 'family', 'safety'];
          const randomTag = defaultTags[Math.floor(Math.random() * defaultTags.length)];
          finalTags = [randomTag];
        }
        
        // Create post with the uploaded image
        const postData = {
          title: title || '',
          tags: finalTags,
          body: body,
          image_path: imagePath,
          status: 'published',
          published_at: new Date().toISOString()
        };
        
        const { error: postError } = await supa.from('posts').insert(postData);
        if (postError) {
          console.error('❌ Post creation failed:', postError);
          throw postError;
        }
        
        console.log('✅ Blog post created:', postData);
        
        // Clear form inputs
        if (titleInput) titleInput.value = '';
        if (tagsInput) tagsInput.value = '';
        if (bodyInput) bodyInput.value = '';
        
        // Clear tags display
        const tagsContainer = document.querySelector('.tags-container');
        if (tagsContainer) {
          tagsContainer.innerHTML = '';
        }
        
        // Clear image preview
        if (imagePreview) {
          imagePreview.src = '';
          imagePreview.style.display = 'none';
        }
        
        // Clear file input
        const fileInput = document.querySelector('input[type="file"]');
        if (fileInput) {
          fileInput.value = '';
        }
        
        // Show success message
        showToast('Blog post created successfully!', 'success');
        
        // Dispatch event to refresh blog
        window.dispatchEvent(new CustomEvent('rfce-posts-updated'));
        
      } catch (err) {
        console.error('❌ Failed to create post:', err);
        showToast('Error: Failed to create post. ' + (err.message || 'Unknown error'), 'error');
      }
    });
  }
  
  // Toast notification function
  function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    const bgColor = type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3';
    
    toast.innerHTML = `
      <div style="font-weight:500;">${message}</div>
    `;
    toast.style.cssText = `
      position:fixed;top:20px;right:20px;background:${bgColor};color:white;
      padding:12px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.2);
      max-width:350px;z-index:1000;font-size:0.9em;
    `;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 5000);
  }
  
  async function loadAdminImages(){
    console.log('📋 Loading gallery images');
    
    // Load gallery images only
    const imgs = await DataService.listImages({ category: 'gallery' });
    if (!imgGrid) return;
    
    console.log(`📋 Found ${imgs.length} gallery images`);
    
    // Simple image grid - no cover selection functionality (like gallery)
    imgGrid.innerHTML = imgs.map(i=>{
      const url = supa.storage.from('images').getPublicUrl(i.path).data.publicUrl;
      
      return `<figure class="admin-image-card" style="position: relative; cursor: pointer;">
        <img src="${url}" alt="${i.alt||''}" loading="lazy" style="width: 100%; height: 150px; object-fit: cover; border-radius: 8px;">
        <figcaption style="padding: 8px; font-size: 0.85rem;">
          ${i.category ? `<span class="category-badge category-badge--${i.category}" style="background: ${i.category === 'blog' ? '#4CAF50' : '#2196F3'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem;">${i.category}</span>` : ''}
          ${i.alt||''}
        </figcaption>
        <button class="btn btn--ghost" data-del-img data-id="${i.id}" data-path="${i.path}" style="position: absolute; top: 4px; right: 4px; background: rgba(255,255,255,0.8);">Delete</button>
      </figure>`;
    }).join('');
    
    imgGrid.querySelectorAll('[data-del-img]').forEach(b=>{
      b.onclick = async ()=>{
        if (confirm('Are you sure you want to delete this item?')) {
          try {
            await DataService.deleteImage(b.dataset.id);
            showToast('Item deleted successfully', 'success');
            await loadAdminImages();
            // Dispatch events to refresh both gallery and blog
            window.dispatchEvent(new CustomEvent('rfce-images-updated'));
            window.dispatchEvent(new CustomEvent('rfce-posts-updated'));
          } catch (err) {
            console.error('❌ Delete failed:', err);
            showToast('Delete failed: ' + err.message, 'error');
          }
        }
      };
    });
  }
  
  // Load blog posts for admin management
  async function loadAdminPosts() {
    try {
      const { data: posts, error } = await supa.from('posts')
        .select('id, title, tags, body, image_path, status, published_at')
        .order('published_at', { ascending: false });
      
      if (error) {
        console.error('❌ Error loading posts:', error);
        return;
      }
      
      console.log(`📝 Admin: Found ${posts.length} blog posts`);
      
      // Create posts management UI if it doesn't exist
      let postsSection = document.querySelector('[data-admin-posts]');
      if (!postsSection) {
        postsSection = document.createElement('div');
        postsSection.setAttribute('data-admin-posts', '');
        postsSection.innerHTML = `
          <h3>Blog Posts Management</h3>
          <div class="admin-posts-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; margin-top: 1rem;"></div>
        `;
        
        // Insert after the images section
        const imagesSection = document.querySelector('[data-admin-images]');
        if (imagesSection && imagesSection.parentNode) {
          imagesSection.parentNode.insertBefore(postsSection, imagesSection.nextSibling);
        }
      }
      
      const postsGrid = postsSection.querySelector('.admin-posts-grid');
      if (!postsGrid) return;
      
      postsGrid.innerHTML = posts.map(post => {
        const url = supa.storage.from('images').getPublicUrl(post.image_path).data.publicUrl;
        const date = new Date(post.published_at).toLocaleDateString();
        const tags = Array.isArray(post.tags) ? post.tags.join(', ') : '';
        
        return `
          <div class="admin-post-card" style="border: 1px solid #ddd; border-radius: 8px; padding: 1rem; background: white;">
            <img src="${url}" alt="${post.title}" style="width: 100%; height: 150px; object-fit: cover; border-radius: 4px; margin-bottom: 0.5rem;">
            <h4 style="margin: 0.5rem 0; font-size: 1rem;">${post.title || 'Untitled'}</h4>
            <p style="font-size: 0.8rem; color: #666; margin: 0.25rem 0;">${date}</p>
            <p style="font-size: 0.8rem; color: #888; margin: 0.25rem 0;">${tags}</p>
            <p style="font-size: 0.8rem; color: #999; margin: 0.5rem 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${post.body ? post.body.substring(0, 100) + '...' : 'No content'}</p>
            <button class="btn btn--ghost" data-del-post data-id="${post.id}" style="background: #f44336; color: white; padding: 0.25rem 0.5rem; font-size: 0.8rem;">Delete Post</button>
          </div>
        `;
      }).join('');
      
      // Add delete handlers for posts
      postsGrid.querySelectorAll('[data-del-post]').forEach(btn => {
        btn.onclick = async () => {
          if (confirm('Are you sure you want to delete this blog post?')) {
            try {
              await DataService.deletePost(btn.dataset.id);
              showToast('Blog post deleted successfully', 'success');
              await loadAdminPosts();
              // Dispatch event to refresh blog
              window.dispatchEvent(new CustomEvent('rfce-posts-updated'));
            } catch (err) {
              console.error('❌ Post delete failed:', err);
              showToast('Delete failed: ' + err.message, 'error');
            }
          }
        };
      });
      
    } catch (err) {
      console.error('❌ Exception loading posts:', err);
    }
  }
  
  // Load both images and posts
  await loadAdminImages();
  await loadAdminPosts();
  
  refresh();
}

// Home Hero Carousel with Supabase Images
async function initHomeHero() {
  if (!document.body.classList.contains('page-home')) return;
  
  const track = document.querySelector('[data-hero-track]');
  const dots = document.querySelector('[data-hero-dots]');
  const prevBtn = document.querySelector('[data-hero-prev]');
  const nextBtn = document.querySelector('[data-hero-next]');
  
  if (!track || !dots) return;
  
  let currentIndex = 0;
  let autoTimer = null;
  let isUserInteracting = false;
  
  try {
    // Fetch 12 most recent GALLERY images only from Supabase
    const { data: images, error } = await supa.from('images')
      .select('path, alt, created_at')
      .eq('category', 'gallery')  // Only show gallery images in hero carousel
      .order('created_at', { ascending: false })
      .limit(12);
    
    console.log('🎠 Hero Carousel: Loading ONLY gallery images (category=gallery)');
    
    if (error) throw error;
    if (!images || images.length === 0) {
      console.log('🎠 Hero Carousel: No gallery images found');
      return;
    }
    
    console.log(`🎠 Hero Carousel: Found ${images.length} gallery images`);
    
    
    // Convert to public URLs
    const slides = images.map(img => {
      const { data: { publicUrl } } = supa.storage.from('images').getPublicUrl(img.path);
      return {
        url: publicUrl,
        alt: img.alt || 'RFCE Community Image',
        path: img.path
      };
    });
    
    // Render slides
    track.innerHTML = slides.map((slide, index) => `
      <div class="carousel-slide ${index === 0 ? 'active' : ''}">
        <img src="${slide.url}" alt="${slide.alt}" loading="lazy" onerror="this.src='assets/img/fallback.jpg'">
      </div>
    `).join('');
    
    // Render dots
    dots.innerHTML = slides.map((_, index) => `
      <button class="carousel-indicator ${index === 0 ? 'active' : ''}" data-index="${index}" aria-label="Go to slide ${index + 1}"></button>
    `).join('');
    
    // Navigation functions
    function goToSlide(index) {
      if (index === currentIndex) return;
      
      // Update slides
      const allSlides = track.querySelectorAll('.carousel-slide');
      const allDots = dots.querySelectorAll('.carousel-indicator');
      
      allSlides[currentIndex]?.classList.remove('active');
      allDots[currentIndex]?.classList.remove('active');
      
      currentIndex = index;
      
      allSlides[currentIndex]?.classList.add('active');
      allDots[currentIndex]?.classList.add('active');
    }
    
    function nextSlide() {
      const nextIndex = (currentIndex + 1) % slides.length;
      goToSlide(nextIndex);
    }
    
    function prevSlide() {
      const prevIndex = (currentIndex - 1 + slides.length) % slides.length;
      goToSlide(prevIndex);
    }
    
    function startAutoSlide() {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = setInterval(nextSlide, 4000);
    }
    
    function stopAutoSlide() {
      if (autoTimer) {
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }
    
    function handleUserInteraction() {
      isUserInteracting = true;
      stopAutoSlide();
      
      // Resume auto-slide after 8 seconds of no interaction
      setTimeout(() => {
        isUserInteracting = false;
        startAutoSlide();
      }, 8000);
    }
    
    // Wire up controls
    if (prevBtn) {
      prevBtn.addEventListener('click', () => {
        prevSlide();
        handleUserInteraction();
      });
    }
    
    if (nextBtn) {
      nextBtn.addEventListener('click', () => {
        nextSlide();
        handleUserInteraction();
      });
    }
    
    // Wire up dots
    dots.addEventListener('click', (e) => {
      const indicator = e.target.closest('[data-index]');
      if (indicator) {
        const index = parseInt(indicator.dataset.index);
        goToSlide(index);
        handleUserInteraction();
      }
    });
    
    // Pause on hover
    const carousel = track.closest('.about-carousel');
    if (carousel) {
      carousel.addEventListener('mouseenter', stopAutoSlide);
      carousel.addEventListener('mouseleave', () => {
        if (!isUserInteracting) {
          startAutoSlide();
        }
      });
    }
    
    // Start auto-slide
    startAutoSlide();
    
  } catch (error) {
    console.error('Failed to load hero carousel images:', error);
    // Fallback: hide carousel or show default content
  }
}

// Blog data purge function (one-time)
async function purgeBlogData() {
  // Check if already purged
  if (localStorage.getItem('rfce:purgedBlog')) {
    console.log('✅ Blog data already purged');
    return;
  }

  console.log('🗑️ Purging blog data...');
  
  try {
    // Delete all posts
    const { error: postsError } = await supa.from('posts').delete().neq('id', 0);
    if (postsError) {
      console.error('❌ Error deleting posts:', postsError);
    } else {
      console.log('✅ All posts deleted');
    }

    // Get all blog images
    const { data: blogImages, error: imagesError } = await supa.from('images').select('id, path').eq('category', 'blog');
    if (imagesError) {
      console.error('❌ Error fetching blog images:', imagesError);
    } else if (blogImages && blogImages.length > 0) {
      // Delete from storage
      const paths = blogImages.map(img => img.path);
      const { error: storageError } = await supa.storage.from('images').remove(paths);
      if (storageError) {
        console.error('❌ Error deleting blog images from storage:', storageError);
      } else {
        console.log('✅ Blog images deleted from storage');
      }

      // Delete from images table
      const { error: deleteError } = await supa.from('images').delete().eq('category', 'blog');
      if (deleteError) {
        console.error('❌ Error deleting blog images from database:', deleteError);
      } else {
        console.log('✅ Blog images deleted from database');
      }
    }

    // Set flag to prevent re-running
    localStorage.setItem('rfce:purgedBlog', 'true');
    console.log('✅ Blog data purge completed');
    
  } catch (error) {
    console.error('❌ Error during blog data purge:', error);
  }
}

// Auto-init
document.addEventListener('DOMContentLoaded', ()=>{
  initHomeHero();
  initGallery();
  initContactForm();
  initAdmin();
  purgeBlogData();
});

// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => RFCEApp.init());